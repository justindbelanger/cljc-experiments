(ns localize-with-html.core
  (:require #?(:clj [clojure.test :refer [deftest is]]
               :cljs [cljs.test :refer-macros [deftest is]])))

(comment
  ;; localize-with-html.
  ;; takes an arg map.
  ;; injects autogenerated strs with the given keys
  ;; into localize-string.
  ;; then cuts up the result and replaces the autogenerated strs
  ;; with the html.
  ;; it's an ugly kludge, but allows us to use ICU MessageFormat
  ;; AND keep complex HTML for the named values in each translated string.
  (map (fn [s]
         (if (= "!PLACEHOLDER!" s)
           [:span {:class "qty"}]
           s))
       (remove empty?
               (clojure.string/split (clojure.string/replace "{QUANTITY} gross floor area"
                                                             "{QUANTITY}"
                                                             "!CUT!!PLACEHOLDER!!CUT!")
                                     #"!CUT!")))
  )

(defn localize-with-html
  "If there is a translation for `s`,
  then replaces named placeholders in `args`
  in the translation and returns it as a vector
  of string segments from the translation
  and values from the named placeholders.
  This allows inserting entire Hiccup HTML
  structures into named spots in a translation.

  Else, evaluates to `s` unchanged."
  ([{:keys         [debug-missing-translations]
     _locale       :locale
     _translations :translations
     :as           translation-config}
    s
    args]
   {:pre [(map? args)]}
   (let [arg-name->placeholder (->> args
                                    (map-indexed
                                     (fn [[i kvp]]
                                       [k (str "!PLACEHOLDER" i "!")]))
                                    (into {}))
         placeholder->arg-name (clojure.set/map-invert arg-name->placeholder)
         translated            (i18n/localize-string* translation-config
                                                      s
                                                      arg-name->placeholder)
         split                 (remove empty?
                                       (clojure.string/split translated
                                                             #"!SNIP!"))
         replaced              (map (fn [s]
                                      (let [arg-name (placeholder->arg-name s)]
                                        (if arg-name
                                          (args arg-name)
                                          s)))
                                    split)]
     (cond
       (some? translated)         replaced
       debug-missing-translations (str "!!!" s "!!!")
       :else                      s)))
  ([translation-config s]
   (localize-with-html translation-config s {})))

(deftest localize-with-html-test
  (testing "Translation with no args should appear without changes."
    (let [translation-config {}
          s
          args ]
      (is (= ""
             (localize-with-html translation-config
                                 s
                                 args))))))
